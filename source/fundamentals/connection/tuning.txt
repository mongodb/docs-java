=================
Connection Storms
=================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _connection-tuning-java:

Overview
--------

In this guide, you can learn about **connection storms** and settings that
can help avoid them.

Connection Storms
-----------------

A **connection storm** is an event in which application servers
start an increasing number of connection requests, but the host server
CPU is unable to schedule them.

.. example::

   Consider an application that uses MongoDB, and is served from an
   auto scaling service. A sudden spike in traffic could cause the scaling
   service to stand up many new application instances. This sudden burst
   in application instances attempting to establish connections to MongoDB
   is one example of a connection storm.

Common Causes and Effects
+++++++++++++++++++++++++

Common causes for connection storms in MongoDB include:

- Incorrect application behavior
- Network latency
- Insufficient hardware for the workload
- Failover events

In MongoDB, connection storms can have multiple effects. For example:

- The high volume of connection requests leads to latency in processing.
- Replication connections between nodes may be blocked or slowed, so replication
  operations cannot proceed.
- Administrative connections to the database are blocked, preventing
  a user from logging in.
- Monitoring connections to the database are blocked, degrading visibility
  into the problem.
- CPU or memory oversubscription due to connection management can lead
  to a ``mongod`` crashing and restarting. This extra workload on the server
  can be exclusively attributed to connection handling.
- In Atlas, connection requests can exceed instance tier limits, causing
  refusal of new connections.

Avoid Connection Storms
-----------------------

While no universal solution exists as each problem is unique to a deployment,
you can use a combination of settings and methods to help you avoid connection
storms. These include:

- **maxPoolSize**: The maximum number of connections in the connection pool. Beginning
  with a lower value is recommended to reduce the maximum pressure each server
  may experience from each connected client applications.
  |
  Fewer overall connections in the pool means the database server is using
  less resources maintaining connections.

- **maxConnecting**: The maximum number of connections the driver can concurrently
  establish to an individual server before making them available in the connection pool.
  |
  By keeping this option low, you reduce the risk temporary load spikes
  from  overwhelming the database.

- **maxTime()**: The *cumulative* time limit for processing operations on
  a MongoDB server.
  |
  Terminating long-running operations frees up resources on the server and
  hints that there may be underlying performance issues (such as a lack of appropriate indexes).

maxPoolSize Recommendations
+++++++++++++++++++++++++++

``maxPoolSize`` specifies the maximum number of connections available in each connection pool.
Begin with a lower value to reduce the maximum pressure each server may
experience from each connected client application. Fewer overall connections
in the pool means the database server is using less resources maintaining connections.


Specify ``maxPoolSize`` in your connection URI or with the
`ConnectionPoolSettings.Builder maxSize() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/connection/ConnectionPoolSettings.Builder.html#maxSize(int)>`__ method.

maxConnecting Recommendations
+++++++++++++++++++++++++++++

``maxConnecting`` specifies the maximum number of connections to each server that
the driver will concurrently establish before making them available in
the connection pool.

.. important:: Start with Lower Values

   Start with lower values for ``maxConnecting``. This helps to avoid bursts
   in connections in response to a temporary increase in traffic.


Do not confuse ``maxConnecting`` with ``maxPoolSize``, which specifies the
maximum number of connections the driver can maintain in the connection pool.

.. example::

   Consider a failover scenario in a three member replica set with applications under
   heavy load. Without ``maxConnecting``, ``maxPoolSize * application servers``
   connections would be established. With default settings for ``maxPoolSize``
   and three application servers, that would be 300 new connections, concurrently.

   With ``maxConnecting`` set to "3", the new primary will receive
   ``maxConnecting * application servers`` connections concurrently, or nine.

Specify ``maxConnecting`` in your connection URI or with the
`ConnectionPoolSettings.Builder maxConnecting() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/connection/ConnectionPoolSettings.Builder.html#maxConnecting(int)>`__ method.


maxTime()
+++++++++


``maxTime()`` specifies the *cumulative* time limit for processing operations
in MongoDB. If an operation exceeds this limit, MongoDB terminates the
operation.

.. tip::

   Use ``maxTime()`` to limit operation execution time. Do not use ``socketTimeoutMS``.

   Closing a socket forces a reconnect, which slows all operations, and does not have any
   impact on the operation that the developer is attempting to abort. MongoDB will continue
   to process the operation, potentially causing errors if the driver attempts to
   retry the operation.

   ``socketTimeoutMS`` specifies the maximum time the driver will wait for socket reads.
   The default is ``0``, meaning no timeout.

   Setting this to a value that is too low results in **connection thrashing**,
   where the socket is closed and removed from the connection pool, and a new
   connection is initiated. For example, setting a timeout of 200 milliseconds
   and issuing a query that takes 300 milliseconds to complete would result in
   the socket being closed and a new connection being initiated.


``maxTime()`` is available on the following classes:

- `AggregateIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `DistinctIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/DistinctIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `FindIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListCollectionsIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/ListCollectionsIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListDatabasesIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/ListDatabasesIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListIndexesIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/ListIndexesIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `MapReduceIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/MapReduceIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `GridFSFindIterable <{+api+}/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSFindIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__



