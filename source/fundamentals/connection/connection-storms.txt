=================
Connection Storms
=================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

.. _connection-storms-java:

Overview
--------

In this guide, you can learn about **connection storms**, common causes,
and how to avoid them.

A **connection storm** is an event in which application servers
start an increasing number of connection requests, but the host server
CPU is unable to schedule them.

.. example::

   Consider popular streaming events such as the World Cup or the Super
   Bowl. Should the stream become unresponsive and all connected clients
   (viewers) refresh their browser, the streaming host would receive a
   new connection request for every connected client. This could
   result in millions of requests per second, overloading the host
   server's CPU.


Common causes for connection storms in MongoDB include:

- Incorrect application behavior
- Network latency
- Insufficient hardware for the workload
- Failover events

In MongoDB, connection storms can have a cascading effect. For example:

#. The high volume of connection requests leads to latency in processing.

#. Replication connections between nodes are blocked or slowed, so replication
operations cannot proceed.

#. Administrative connections to the database are blocked, preventing
a user from logging in.

#. Monitoring connections to the database are blocked, degrading visibility
into the problem.

#. CPU or memory oversubscription due to connection management can lead
to a ``mongod`` crashing and restarting. This extra workload on the server
can be exclusively attributed to connection handling.

#. In Atlas, connection requests can exceed instance class limits, causing
refusal of new connections.

Avoiding Connection Storms
--------------------------

A combination of settings and methods can help to mitigate connection storms.
These include:

- **maxConnecting**: The maximum number of connections a Pool may be
establishing concurrently.

- **socketTimeoutMS**: The maximum time the driver will wait for socket
reads.

- **maxTime()**: The *cumulative* time limit for processing operations on
  a MongoDB server.

**maxConnecting**
+++++++++++++++++

``maxConnecting`` specifies the maximum number of connections a Pool may be establishing
concurrently. The default is 2.

This is not to be confused with ``maxPoolSize``, which specifies the maximum
number of connections that the driver maintains in the connection pool.

.. example::

   Consider a new application instance connecting to a single MongoDB server, using
   the default values of **2** for ``maxConnecting`` and **100** for ``maxPoolSize``.
   If it takes ~50 milliseconds to establish a connection, the connection pool
   would take 2.5 seconds (50 milliseconds [latency] * 100 [``maxPoolSize``] / 2 [``maxConnecting``])
   to fill.

   In another scenario, consider an application servers connecting to a 3 member
   replica set, using the default values for ``maxConnecting`` and ``maxPoolSize``.
   The application server creates a connection pool to each member of the replica set.
   If it takes ~50 milliseconds to establish a connection, the connection pools
   would still take 2.5 seconds to fill.


**socketTimeoutMS**
+++++++++++++++++++

``socketTimeoutMS`` specifies the maximum time the driver will wait for socket reads.
The default is **0**, meaning no timeout and relying on the underlying system default for socket timeout.

Setting this to a value that is too low results in **connection thrashing**,
where the socket is closed and removed from the connection pool, and a new
connection is initiated. For example, setting a timeout of 200 milliseconds
and issues a query that takes 300 milliseconds to complete would result in
the socket being closed and a new connection being initiated.

.. warning:: Not for Aborting Operations

   Some users have incorrectly used this option to try to abort operations
   which run for too long and slow down other operations. Closing a socket
   forces a reconnect, which slows all operations, and does not have any
   impact on the operation that the developer is attempting to abort. MongoDB will continue
   to process the operation, potentially causing errors if the driver attempts to
   retry the operation.

**maxTime()**
+++++++++++++

``maxTime()`` specifies the *cumulative* time limit for processing operations
in MongoDB. If an operation exceeds this limit, MongoDB terminates the
operation.

``maxTime()`` is available on the following classes:

- `AggregateIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `DistinctIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/DistinctIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `FindIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListCollectionsIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/ListCollectionsIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListDatabasesIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/ListDatabasesIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `ListIndexesIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/ListIndexesIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `MapReduceIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/MapReduceIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__
- `GridFSFindIterable <{+api}/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSFindIterable.html#maxTime(long,java.util.concurrent.TimeUnit)>`__

.. tip:: Use ``maxTime``

   Use ``maxTimeMS`` to limit operation execution time. Do not use ``socketTimeoutMS``.




