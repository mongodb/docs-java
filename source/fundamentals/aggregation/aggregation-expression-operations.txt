=================================
Aggregation Expression Operations
=================================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to use the {+driver-long+} to construct
expressions for use in the aggregation pipeline. You can perform
expression operations with discoverable, typesafe Java methods rather
than BSON documents. Because these methods follow the fluent interface
pattern, you can chain aggregation operations together to create code
that is both more compact and more naturally readable.

The operations in this guide use methods from the
`com.mongodb.client.model.mql <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/package-summary.html>`__ package.
These methods provide an idiomatic way to use the Query API,
the mechanism by which the driver interacts with the {+mdb-server+}. To learn more
about the Query API, see the :manual:`Server manual documentation </query-api/>`.

How to Use Operations
---------------------

The examples in this guide assume that you include the following static
imports in your code:

.. code-block:: java
   :copyable: true

   import static com.mongodb.client.model.Aggregates.*;
   import static com.mongodb.client.model.Projections.*;
   import static com.mongodb.client.model.Filters.*;
   import static com.mongodb.client.model.mql.MqlValues.*;
   import static java.util.Arrays.asList;

To access document fields in an expression, you need to reference the
document being processed by the aggregation pipeline. Use the
``current()`` method to refer to this document. To access the value of a
field, you must use the appropriately typed method, such as
``getString()`` or ``getDate()``. When you specify the type for a field,
you ensure that the driver provides only those methods which are
compatible with that type. The following code shows how to reference a
string field called ``name``:

.. code-block:: java
   :copyable: true
   
   current().getString("name")

To specify a value in an operation, pass it to the ``of()`` method to
convert it to a valid type. The following code shows how to reference a
value of ``1.0``:

.. code-block:: java
   :copyable: true
   
   of(1.0)

To create an operation, chain a method to your field or value reference.
You can build more complex operations by chaining additional methods.

The following example creates an operation to find patients in New
Mexico who have visited the doctor’s office at least once. The operation
performs the following actions:

- Checks if the size of the ``visitDates`` array is greater than ``0``
  by using the ``gt()`` method 
- Checks if the ``state`` field value is “New Mexico” by using the
  ``eq()`` method

The ``and()`` method links these operations so that the pipeline stage
matches only documents that meet both criteria.

.. code-block:: java
   :copyable: true
      
   current()
         .getArray("visitDates")
         .size()
         .gt(of(0))
         .and(current()
                 .getString("state")
                 .eq(of("New Mexico")));

While some aggregation stages, such as ``group()``, accept operations
directly, other stages expect that you first include your operation in a
method such as ``computed()`` or ``expr()``. These methods, which take
values of type ``TExpression``, allow you to use your expressions in
certain aggregations.

To complete your aggregation pipeline stage, include your expression
in an aggregates builder method. The following list provides examples of
how to include your expression in common aggregates builder methods:

- ``match(expr(<expression>))``
- ``project(fields(computed("<field name>", <expression>)))``
- ``group(<expression>)``

To learn more about these methods, see
:ref:`Aggregates Builders <aggregates-builders>`.

The examples use the ``Arrays.asList()`` method to create a list of
aggregation stages. This list is passed to the ``aggregate()`` method of
``MongoCollection``.

Operations
----------

The following sections provide information and examples for
aggregation expression operations available in the driver.
The operations are categorized by purpose and functionality.

Each section has a table that describes aggregation methods
available in the driver and corresponding expression operators in the
Query API. The method names link to API documentation and the
aggregation pipeline operator names link to descriptions and examples in
the Server manual documentation.

.. note::

   The driver generates a Query API expression that may be different
   from the Query API expression provided in each example. However,
   both expressions will produce the same aggregation result.

.. important::

   The driver does not provide methods for all aggregation pipeline operators in
   the Query API. If you need to use an unsupported operation in an
   aggregation, you can create an expression as a BSON ``Document``
   type. To learn more about the ``Document`` type, see :ref:`<fundamentals-documents>`.

Arithmetic Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform an arithmetic operation on a value of type ``MqlInteger`` or
``MqlNumber`` using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `abs() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#abs()>`__
     - :manual:`$abs </reference/operator/aggregation/abs/>`

   * - `add() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#add(com.mongodb.client.model.mql.MqlNumber)>`__
     - :manual:`$add </reference/operator/aggregation/add/>`

   * - `divide() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#divide(com.mongodb.client.model.mql.MqlNumber)>`__
     - :manual:`$divide </reference/operator/aggregation/divide/>`

   * - `multiply() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#multiply(com.mongodb.client.model.mql.MqlNumber)>`__
     - :manual:`$multiply </reference/operator/aggregation/multiply/>`

   * - `round() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#round()>`__
     - :manual:`$round </reference/operator/aggregation/round/>`

   * - `subtract() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#subtract(com.mongodb.client.model.mql.MqlNumber)>`__
     - :manual:`$subtract </reference/operator/aggregation/subtract/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you need to calculate the total cost of a sale from the item's
price, the quantity sold, and an applicable discount.

To calculate the cost of the sale, multiply the ``itemPrice`` and the ``quantity``
fields by using the ``multiply()`` method. To apply the ``discount``, use the
``subtract()`` method. To output the result in a new ``totalSale`` field, use
the ``project()`` method.

The following code shows the pipeline for this aggregation and assigns
cost of the sale to a new field ``totalSale``:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
            computed("totalSale",
               current()
                  .getInteger("itemPrice")
                  .multiply(current()
                     .getInteger("quantity"))
                  .subtract(current()
                     .getInteger("discount")))
   )));

The following code provides an equivalent aggregation pipeline in the
Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         totalSale: {
           $subtract: [
             { $multiply: [ "$itemPrice", "$quantity" ] },
             "$discount"
            ]
         }
       }
     }
   ]

Array Operations
~~~~~~~~~~~~~~~~

You can perform an array operation on a value of type ``MqlArray``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `all() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#all(java.util.function.Function)>`__
     - :manual:`$allElementsTrue </reference/operator/aggregation/allElementsTrue/>`

   * - `any() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#any(java.util.function.Function)>`__
     - :manual:`$anyElementTrue </reference/operator/aggregation/anyElementTrue/>`

   * - `concat() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#concat(com.mongodb.client.model.mql.MqlArray)>`__
     - :manual:`$concatArrays </reference/operator/aggregation/concatArrays/>`

   * - `contains() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#contains(T)>`__
     - :manual:`$in </reference/operator/aggregation/in/>`

   * - `distinct() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#distinct()>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`

   * - `elementAt() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#elementAt(int)>`__
     - :manual:`$arrayElemAt </reference/operator/aggregation/arrayElemAt/>`

   * - `filter() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#filter(java.util.function.Function)>`__
     - :manual:`$filter </reference/operator/aggregation/filter/>`

   * - `first() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#first()>`__
     - :manual:`$first </reference/operator/aggregation/first-array-element/>`

   * - `joinStrings() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#joinStrings(java.util.function.Function)>`__
     - :manual:`$concat </reference/operator/aggregation/concat/>`

   * - `last() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#last()>`__
     - :manual:`$last </reference/operator/aggregation/last-array-element/>`

   * - `map() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#map(java.util.function.Function)>`__
     - :manual:`$map </reference/operator/aggregation/map/>`

   * - `max() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#max(T)>`__
     - :manual:`$max </reference/operator/aggregation/max/>`

   * - `maxN() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#maxN(com.mongodb.client.model.mql.MqlInteger)>`__
     - :manual:`$maxN </reference/operator/aggregation/maxN-array-element/>`

   * - `min() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#min(T)>`__
     - :manual:`$min </reference/operator/aggregation/min/>`

   * - `minN() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#minN(com.mongodb.client.model.mql.MqlInteger)>`__
     - :manual:`$map </reference/operator/aggregation/minN-array-element/>`

   * - `multiply() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#multiply(java.util.function.Function)>`__
     - :manual:`$multiply </reference/operator/aggregation/multiply/>`

   * - `size() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#size()>`__
     - :manual:`$size </reference/operator/aggregation/size/>`

   * - `slice() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#slice(int,int)>`__
     - :manual:`$slice </reference/operator/aggregation/slice/>`

   * - `sum() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#sum(java.util.function.Function)>`__
     - :manual:`$sum </reference/operator/aggregation/sum/>`

   * - `unionArrays() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#unionArrays(java.util.function.Function)>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you have a collection of movies, each of which contains an array
of nested documents for upcoming showtimes. Each nested document
contains an array that represents the total number of seats in the
theater, where the first array entry is the number of premium seats and
the second entry is the number of regular seats. Each nested document
also contains the number of tickets that have already been bought for
the showtime. A document in this collection might resemble the
following:

.. code-block:: json
   :copyable: false

   {
     "_id": ...,
     "movie": "Hamlet",
     "showtimes": [
       {
         "date": "May 14, 2023, 12:00 PM",
         "seats": [ 20, 80 ],
         "ticketsBought": 100
       },
       {
         "date": "May 20, 2023, 08:00 PM",
         "seats": [ 10, 40 ],
         "ticketsBought": 34
       }
     ]
   }

To see only showtimes with available tickets, pass a predicate to the
``filter()`` method. Within this predicate, calculate the total number
of seats by taking the sum of the ``seats`` array by using the ``sum()``
method. Check if ``ticketsBought`` is less than the total number of
seats by using the ``lt()`` method. To output the showtimes with
available tickets as the ``availableShowtimes`` array, use the
``project()`` method.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
           computed("availableShowtimes",
                   current()
                           .<MqlDocument>getArray("showtimes")
                           .filter(showtime -> {
                               var totalSeats = showtime
                                       .<MqlInteger>getArray("seats")
                                       .sum(n -> n);
                               var isAvailable = showtime
                                       .getInteger("ticketsBought")
                                       .lt(totalSeats);
                               return isAvailable;
                           })
   ))));

.. note::

   To improve readability, the previous example assigns intermediary values to
   the ``totalSeats`` and ``isAvailable`` variables. If you don't pull
   out these intermediary values as variables, the code still produces
   equivalent results.

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         availableShowtimes: {
           $filter: {
             input: "$showtimes",
             as: "showtime",
             cond: { $lt: [ "$$showtime.ticketsBought", { $sum: "$$showtime.seats" } ] }
           }
         }
       }
     }
   ]

Boolean Operations
~~~~~~~~~~~~~~~~~~

You can perform a boolean operation on a value of type ``MqlBoolean``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `and() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#and(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$and </reference/operator/aggregation/and/>`
       
   * - `not() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#not()>`__
     - :manual:`$not </reference/operator/aggregation/not/>`

   * - `or() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#or(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$or </reference/operator/aggregation/or/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you want to classify very low or high weather temperature
readings (in degrees Fahrenheit) as extreme.

To evaluate if the ``temperature`` field is greater than 95, use the
``gt()`` method. To evaluate if the ``temperature`` field is less
than 10, use the ``lt()`` method. To return ``true`` if either condition is
satisfied, use the ``or()`` method. To output the result as the
``extremeTemp`` field, use the ``project()`` method.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   var temperature = current().getInteger("temperature");

   Arrays.asList(project(fields(
               computed("extremeTemp",
                   temperature
                       .lt(of(10))
                       .or(temperature.gt(of(95)))
    )
   )));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         extremeTemp: { $or: [ { $lt: ["$temperature", 10] },
                               { $gt: ["$temperature", 95] },
         ] }
       }
     }
   ]

Comparison Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform a comparison operation on a value of type ``MqlValue``
using the methods described in this section. For more information about how
the driver compares values of different types, see
:manual:`Aggregation Pipeline Operators </reference/bson-type-comparison-order/#std-label-bson-types-comparison-order>`
in the Server manual.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `eq() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#eq(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$eq </reference/operator/aggregation/eq/>`

   * - `gt() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#gt(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$gt </reference/operator/aggregation/gt/>`

   * - `gte() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#gte(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$gte </reference/operator/aggregation/gte/>`

   * - `lt() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#lt(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$lt </reference/operator/aggregation/lt/>`

   * - `lte() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#lte(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$lte </reference/operator/aggregation/lte/>`

   * - `ne() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#ne(com.mongodb.client.model.mql.MqlValue)>`__
     - :manual:`$ne </reference/operator/aggregation/ne/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

The following example shows a pipeline that matches all the documents
where the ``location`` field has the value ``"California"``:

.. code-block:: java
   :copyable: true

   Arrays.asList(match(
         expr(current()
            .getString("location")
               .eq(of("California"))
   )));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $match: { $eq: [ "$location", "California"] }
     }
   ]

Conditional Operations
~~~~~~~~~~~~~~~~~~~~~~

You can perform a conditional operation using the methods described in
this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `cond() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#cond(T,T)>`__
     - :manual:`$cond </reference/operator/aggregation/cond/>`

   * - `switchOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#switchOn(java.util.function.Function)>`__

       | **Typed Variants**:
       | `switchArrayOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#switchArrayOn(java.util.function.Function)>`__
       | `switchBooleanOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#switchBooleanOn(java.util.function.Function)>`__
       | `switchDateOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#switchDateOn(java.util.function.Function)>`__
       | `switchDocumentOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDocument.html#switchDocumentOn(java.util.function.Function)>`__
       | `switchIntegerOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlInteger.html#switchIntegerOn(java.util.function.Function)>`__
       | `switchMapOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlMap.html#switchMapOn(java.util.function.Function)>`__
       | `switchNumberOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#switchNumberOn(java.util.function.Function)>`__
       | `switchStringOn() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#switchStringOn(java.util.function.Function)>`__

     - :manual:`$switch </reference/operator/aggregation/switch/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you have a collection of customers with their membership information.
Originally, customers were either members or not. Over time, membership levels
were introduced and used the same field. The information stored in this field
can be one of a few different types, and you want to create a consistent field
indicating their membership level.

To change what you are doing based on the data type of ``member``, use the
``switchOn()`` method. If the data type is a string, it indicates the
membership level and you want to use the data without altering it. If the data
type is ``Boolean``, check the value with the ``cond()`` method and return a
string depending on the result. The default membership level is "Gold". If the
data type is ``Array``, it lists all of the customer's subscriptions, with the
last one in the array being the current membership. Get the last element using
the ``last()`` method. If it is not one of these types, label them as a "Guest"
by using ``defaults()``. Regardless of the type, use the ``project()`` method
to output the result as ``membershipLevel``.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
         computed("membershipLevel",
               current().getField("member").switchOn(field -> field
                        .isString(s -> s)
                        .isBoolean(b -> b.cond(of("Gold"), of("Guest")))
                        .<MqlString>isArray(a -> a.last())
                        .defaults(d -> of("Guest"))
               ))
   )));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         result: {
           $switch: {
             branches: [
               { case:
                 { $eq: [ { $type: "$member" }, "string" ] },
                 then: "$member"
               },
               { case:
                 { $eq: [ { $type: "$member" }, "bool" ] },
                 then: {
                   $cond: { if: "$member",
                     then: "Gold",
                     else: "Guest" } } 
                 },
               { case:
                 { $eq: [ { $type: "$member" }, "array" ] },
                 then: { $last: "$member" }
               }
             ],
             default: "Guest"
           }
         }
       }
     }
   ]

Conversion Operations
~~~~~~~~~~~~~~~~~~~~~

You can perform a conversion operation to convert between ``MqlValue``
types using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `asDocument() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlMap.html#asDocument()>`__
     - *No corresponding operator*
       
   * - `asMap() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDocument.html#asMap()>`__
     - *No corresponding operator*

   * - `asString() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#asString()>`__
     - :manual:`$toString </reference/operator/aggregation/toString/>`

   * - `asString() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#asString(com.mongodb.client.model.mql.MqlString,com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dateToString </reference/operator/aggregation/dateToString/>`

   * - `millisecondsAsDate() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlInteger.html#millisecondsAsDate()>`__
     - :manual:`$toDate </reference/operator/aggregation/toDate/>`

   * - `parseDate() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#parseDate()>`__
     - :manual:`$dateFromString </reference/operator/aggregation/dateFromString/>`

   * - `parseInteger() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#parseInteger()>`__
     - :manual:`$toInt </reference/operator/aggregation/toInt/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you want to have a collection of student data that includes
their graduation years, which are stored as strings. You want to
calculate the year of their five-year reunion and store this value in a
new field.

To convert the ``graduationYear`` field to an integer,
use the ``parseInteger()`` method. To add five years to this value, use the
``add()`` method. To store the result as ``reunionYear``,
use the ``addFields()`` method.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(addFields(
           new Field("reunionYear", current()
                   .getString("graduationYear")
                   .parseInteger()
                   .add(5))
   ));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $addFields: {
         reunionYear: {
           $add: [ { $toInt: "$graduationYear" }, 5 ]
         }
       }
     }
   ]

Custom Operations
~~~~~~~~~~~~~~~~~

You can apply custom functions to values of type
``MqlValue`` using the methods described in this section.

To improve readability and allow for code reuse, you can move redundant
code into static methods. However, it is not possible to directly chain
static methods in Java. The ``passTo()`` method lets you chain values
into custom static methods.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `passTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlValue.html#passTo(java.util.function.Function)>`__
       
       | **Typed Variants**:
       | `passArrayTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#passArrayTo(java.util.function.Function)>`__
       | `passBooleanTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#passBooleanTo(java.util.function.Function)>`__
       | `passDateTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#passDateTo(java.util.function.Function)>`__
       | `passDocumentTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDocument.html#passDocumentTo(java.util.function.Function)>`__
       | `passIntegerTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlInteger.html#passIntegerTo(java.util.function.Function)>`__
       | `passMapTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlMap.html#passMapTo(java.util.function.Function)>`__
       | `passNumberTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlNumber.html#passNumberTo(java.util.function.Function)>`__
       | `passStringTo() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#passStringTo(java.util.function.Function)>`__

     - *No corresponding operator*

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you need to determine how a class is performing against some
benchmarks. You want to find the average final grade for each class and
compare it against the benchmark values.

To calculate each class average, write an averaging method called
``gradeAverage()`` and pass the ``students`` array to this method by using
the ``passArrayTo()`` method. To compare each class average against your
defined benchmarks, write a method called ``evaluate()``. Apply this
method to the class averages by chaining the ``passNumberTo()`` method
to the previous method. To output the result as the ``evaluation``
field, use the ``project()`` method.

The following code shows sample implementations of the methods used in
this aggregation:

.. code-block:: java
   :copyable: true

   public static MqlNumber gradeAverage(MqlArray<MqlDocument> students, String fieldName) {
       var sum = students.sum(student -> student.getInteger(fieldName));
       var avg = sum.divide(students.size());
       return avg;
   }

   public static MqlString evaluate(MqlNumber grade, MqlNumber cutoff1, MqlNumber cutoff2) {
       var message = grade.switchOn(on -> on
               .lte(cutoff1, g -> of("Needs improvement"))
               .lte(cutoff2, g -> of("Meets expectations"))
               .defaults(g -> of("Exceeds expectations")));
       return message;
   }

.. tip::

   One advantage of using the ``passTo()`` method is that you can reuse
   your custom methods for other aggregations. You could
   use the ``gradeAverage()`` method to find the average of grades for
   groups of students filtered by, for example, entry year or district, not just their
   class. You could use the ``evaluate()`` method to evaluate, for
   example, an individual student's performance, or an entire school's or
   district's performance.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
           computed("evaluation",
                   current().<MqlDocument>getArray("students")
                           .passArrayTo(students -> gradeAverage(students, "finalGrade"))
                           .passNumberTo(grade -> evaluate(grade, of(70), of(85)))
   ))));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         evaluation: {
           $switch: {
             branches: [
               { case: { $lte: [ { $avg: "$students.finalGrade" }, 70 ] },
                 then: "Needs improvement"
               },
               { case: { $lte: [ { $avg: "$students.finalGrade" }, 85 ] },
                 then: "Meets expectations"
               }
             ],
             default: "Exceeds expectations" }
           }
         }
       }
     }
   ]

Date Operations
~~~~~~~~~~~~~~~

You can perform a date operation on a value of type ``MqlDate``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `dayOfWeek() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#dayOfWeek(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfWeek </reference/operator/aggregation/dayOfWeek/>`

   * - `dayOfMonth() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#dayOfMonth(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfMonth </reference/operator/aggregation/dayOfMonth/>`

   * - `dayOfYear() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#dayOfYear(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$dayOfYear </reference/operator/aggregation/dayOfYear/>`

   * - `year() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#year(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$year </reference/operator/aggregation/year/>`

   * - `month() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#month(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$month </reference/operator/aggregation/month/>`

   * - `week() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#week(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$week </reference/operator/aggregation/week/>`

   * - `hour() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#hour(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$hour </reference/operator/aggregation/hour/>`

   * - `minute() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#minute(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$minute </reference/operator/aggregation/minute/>`

   * - `second() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#second(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$second </reference/operator/aggregation/second/>`

   * - `millisecond() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlDate.html#millisecond(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$millisecond </reference/operator/aggregation/millisecond/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you have data about package deliveries and need to match
deliveries that occurred on any Monday in the ``"America/New_York"`` time
zone.

If the ``deliveryDate`` field contains any string values representing
valid dates, such as ``"2018-01-15T16:00:00Z"`` or ``Jan 15, 2018, 12:00
PM EST``, you can use the ``parseDate()`` method to convert the strings
into date types.

To get the day of the week (as a number) from the date, use the ``dayOfWeek()``
method and pass ``"America/New_York"`` as a parameter to specify that
you are using that time zone to define when Monday is. Use the
``eq()`` method to check if the day value is ``2``, corresponding to Monday.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(match(
        expr(current()
                .getString("deliveryDate")
                .parseDate()
                .dayOfWeek(of("America/New_York"))
                .eq(of(2)))
   ));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $match: {
         $expr: {
           $eq: [
             {
               $dayOfWeek: { 
                 date: { $dateFromString: { dateString: "$deliveryDate" } },
                 timezone: "America/New_York"
               }
             },
             2
           ]
         }
       }
     }
   ]

Set Operations
~~~~~~~~~~~~~~

You can perform a set operation on a value of type ``MqlArray`` using the
methods described in this section. These operations treat the arrays as sets.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `union() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#union(com.mongodb.client.model.mql.MqlArray)>`__
     - :manual:`$setUnion </reference/operator/aggregation/setUnion/>`
       
.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you have a collection describing music teachers, and for each teacher,
there are arrays of students for each of their classes. You want to create a
list of all the students a teacher has by combining the class rosters.

To combine the ``pianoStudents`` and ``choirStudents`` arrays, use the
``union()`` method. To output the result as a new ``allStudents`` field, use
the ``project()`` method.

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
         computed("allStudents",
               current()
                     .getArray("pianoStudents")
                     .union((current()
                           .getArray("choirStudents"))))
   )));


The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         allStudents: {
            $setUnion: ["$pianoStudents", "$choirStudents"]
         }
       }
     }
   ]

String Operations
~~~~~~~~~~~~~~~~~

You can perform a string operation on a value of type ``MqlString``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `append() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#append(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$concat </reference/operator/aggregation/concat/>`
       
   * - `toLower() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#toLower()>`__
     - :manual:`$toLower </reference/operator/aggregation/toLower/>`

   * - `toUpper() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#toUpper()>`__
     - :manual:`$toUpper </reference/operator/aggregation/toUpper/>`

   * - `length() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#length()>`__
     - :manual:`$strLenCP </reference/operator/aggregation/strLenCP/>`

   * - `lengthBytes() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#lengthBytes()>`__
     - :manual:`$strLenBytes </reference/operator/aggregation/strLenBytes/>`

   * - `substr() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#substr(int,int)>`__
     - :manual:`$substrCP </reference/operator/aggregation/substrCP/>`

   * - `substrBytes() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#substrBytes(int,int)>`__
     - :manual:`$substrBytes </reference/operator/aggregation/substrBytes/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you need to generate lowercase usernames for employees of a
company from the employees' last names and employee IDs.

To concatenate the ``lastName`` and ``employeeID`` fields,
use the ``append()`` method. To make the username lowercase, use the
``toLower()`` method. To output the result as the ``username`` field,
use the ``project()`` method.

The following code shows the pipeline for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
           computed("username",
                   current()
                           .getString("lastName")
                           .append(current()
                                   .getString("employeeID"))
                           .toLower()
   ))));
   
The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         username: {
           $toLower: {
             $concat: ["$lastName", "$employeeID"],
           }
         }
       }
     }
   ]

More Information
----------------
