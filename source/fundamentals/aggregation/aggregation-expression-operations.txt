=================================
Aggregation Expression Operations
=================================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to use the {+driver-long+} to construct
expressions for use in the aggregation pipeline. You can perform
expression operations with discoverable, typesafe Java methods rather
than BSON documents. Because these methods follow the fluent interface
pattern, you can chain aggregation operations together to create code
that is both more compact and more naturally readable.

The operations in this guide use methods from the
`com.mongodb.client.model.mql <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/package-summary.html>`__ package.
These methods provide an idiomatic way to use the Query API,
the mechanism by which the driver interacts with the {+mdb-server+}. To learn more
about the Query API, see the :manual:`Server manual documentation </query-api/>`.

How to Use Operations
---------------------

The examples in this guide assume that you include the following static
imports in your code:

.. code-block:: java
   :copyable: true

   import static com.mongodb.client.model.Aggregates.*;
   import static com.mongodb.client.model.Projections.*;
   import static com.mongodb.client.model.Filters.*;
   import static com.mongodb.client.model.mql.MqlValues.*;
   import static java.util.Arrays.asList;

To access document fields in an expression, you need to reference the
document being processed by the aggregation pipeline. Use the
``current()`` method to refer to this document. To access the value of a
field, you must use the appropriately typed method, such as
``getString()`` or ``getDate()``. When you specify the type for a field,
you ensure that the driver provides only those methods which are
compatible with that type. The following code shows how to reference a
string field called ``name``:

.. code-block:: java
   :copyable: true
   
   current().getString("name")

To specify a value in an operation, pass it to the ``of()`` method to
convert it to a valid type. The following code shows how to reference a
value of ``1.0``:

.. code-block:: java
   :copyable: true
   
   of(1.0)

To create an operation, chain a method to your field or value reference.
You can build more complex operations by chaining additional methods.

The following example creates an operation to find patients in New
Mexico who have visited the doctor’s office at least once. The operation
performs the following actions:

- Checks if the size of the ``visitDates`` array is greater than ``0``
  by using the ``gt()`` method 
- Checks if the ``state`` field value is “New Mexico” by using the
  ``eq()`` method

The ``and()`` method links these operations so that the pipeline stage
matches only documents that meet both criteria.

.. code-block:: java
   :copyable: true
      
   current()
         .getArray("visitDates")
         .size()
         .gt(of(0))
         .and(current()
                 .getString("state")
                 .eq(of("New Mexico")));

While some aggregation stages, such as ``group()``, accept operations
directly, other stages expect that you first include your operation in a
method such as ``computed()`` or ``expr()``. These methods, which take
values of type ``TExpression``, allow you to use your expressions in
certain aggregations.

To complete your aggregation pipeline stage, include your expression
in an aggregates builder method. The following list provides examples of
how to include your expression in common aggregates builder methods:

- ``match(expr(<expression>))``
- ``project(fields(computed("<field name>", <expression>)))``
- ``group(<expression>)``

To learn more about these methods, see
:ref:`Aggregates Builders <aggregates-builders>`.

The examples use the ``Arrays.asList()`` method to create a list of
aggregation stages that is passed to the ``aggregate()`` method of
``MongoCollection``.

Operations
----------

The following sections provide information and examples for
aggregation expression operations available in the driver.
The operations are categorized by purpose and functionality.

Each section has a table that describes aggregation methods
available in the driver and corresponding expression operators in the
Query API. The method names link to API documentation and the
aggregation pipeline operator names link to descriptions and examples in
the Server manual documentation.

.. note::

   The driver generates a Query API expression that may be different
   from the Query API expression provided in each example. However,
   both expressions will produce the same aggregation result.

Array Operations
~~~~~~~~~~~~~~~~

You can perform an array operation on a value of type ``MqlArray``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `concat() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#concat(com.mongodb.client.model.mql.MqlArray)>`__
     - :manual:`$concatArrays </reference/operator/aggregation/concatArrays/>`

   * - `contains() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#contains(T)>`__
     - :manual:`$in </reference/operator/aggregation/in/>`

   * - `elementAt() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#elementAt(int)>`__
     - :manual:`$arrayElemAt </reference/operator/aggregation/arrayElemAt/>`

   * - `filter() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#filter(java.util.function.Function)>`__
     - :manual:`$filter </reference/operator/aggregation/filter/>`

   * - `first() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#first()>`__
     - :manual:`$first </reference/operator/aggregation/first/>`

   * - `last() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#last()>`__
     - :manual:`$last </reference/operator/aggregation/last/>`

   * - `map() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#map(java.util.function.Function)>`__
     - :manual:`$map </reference/operator/aggregation/map/>`

   * - `size() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#size()>`__
     - :manual:`$size </reference/operator/aggregation/size/>`

   * - `slice() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlArray.html#slice(int,int)>`__
     - :manual:`$slice </reference/operator/aggregation/slice/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you have a collection of movies, each of which contains an array
of nested documents for upcoming showtimes. Each nested document
also contains the total number of seats in the theater and number of
tickets that have already been bought for the showtime. You want to see
only showtimes that still have available tickets.

To find the number of tickets that are still available for a showtime,
subtract the ``ticketsBought`` field from the ``seats`` field by
using the ``subtract()`` method. To filter for events with available
tickets, pass a predicate to the ``filter()`` method that checks if the
number of available tickets is greater than ``0`` by using the ``gt()``
method. To output the showtimes with available tickets as the
``hasTicketsAvailable`` array, use the ``project()`` method.

The following code shows the pipeline stage for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
                   computed("hasTicketsAvailable",
                           current()
                                   .<MqlDocument>getArray("showtimes")
                                   .filter(e -> e
                                           .getInteger("seats")
                                           .subtract(e
                                                   .getInteger("ticketsBought"))
                                           .gt(of(0)))
   ))));

.. note:: Referencing Nested Documents and Fields

   The preceding example references the ``seats`` and ``ticketsBought`` fields,
   which are in nested documents in the ``showtimes`` array. To access
   these fields, you must specify that the return type of ``getArray()``
   is an ``MqlArray`` of ``MqlDocument`` values.

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         hasTicketsAvailable: {
           $filter: {
             input: "$showtimes",
             as: "e",
             cond: {
               $gt: [
                 { $subtract: [
                     "$$e.seats",
                     "$$e.ticketsBought",
                   ] }, 0 ]
             } } } }
     }
   ]

Boolean Operations
~~~~~~~~~~~~~~~~~~

You can perform a boolean operation on a value of type ``MqlBoolean``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `and() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#and(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$and </reference/operator/aggregation/and/>`
       
   * - `not() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#not()>`__
     - :manual:`$not </reference/operator/aggregation/not/>`

   * - `or() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlBoolean.html#or(com.mongodb.client.model.mql.MqlBoolean)>`__
     - :manual:`$or </reference/operator/aggregation/or/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you want to classify very low or high weather temperature
readings (in degrees Fahrenheit) as extreme.

To evaluate if the ``temperature`` field is greater than 95, use the
``gt()`` method. To evaluate if the ``temperature`` field is less
than 10, use the ``lt()`` method. To return ``true`` if either condition is
satisfied, use the ``or()`` method. To output the result as the
``extremeTemp`` field, use the ``project()`` method.

The following code shows the pipeline stage for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
                   computed("extremeTemp",
                           current()
                                   .getInteger("temperature")
                                   .lt(of(10))
                                   .or(current()
                                           .getInteger("temperature")
                                           .gt(of(95)))
   ))));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         extremeTemp: { $or: [ { $lt: ["$temperature", 10] },
                               { $gt: ["$temperature", 95] },
           ] } }
     }
   ]

String Operations
~~~~~~~~~~~~~~~~~

You can perform a string operation on a value of type ``MqlString``
using the methods described in this section.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Java Method
     - Aggregation Pipeline Operator

   * - `append() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#append(com.mongodb.client.model.mql.MqlString)>`__
     - :manual:`$concat </reference/operator/aggregation/concat/>`
       
   * - `toLower() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#toLower()>`__
     - :manual:`$toLower </reference/operator/aggregation/toLower/>`

   * - `toUpper() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#toUpper()>`__
     - :manual:`$toUpper </reference/operator/aggregation/toUpper/>`

   * - `length() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#length()>`__
     - :manual:`$strLenCP </reference/operator/aggregation/strLenCP/>`

   * - `lengthBytes() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#lengthBytes()>`__
     - :manual:`$strLenBytes </reference/operator/aggregation/strLenBytes/>`

   * - `substr() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#substr(int,int)>`__
     - :manual:`$substrCP </reference/operator/aggregation/substrCP/>`

   * - `substrBytes() <{+api+}/apidocs/mongodb-driver-core/com/mongodb/client/model/mql/MqlString.html#substrBytes(int,int)>`__
     - :manual:`$substrBytes </reference/operator/aggregation/substrBytes/>`

.. include:: /includes/fundamentals/agg-mql-diff.rst

Suppose you need to generate lowercase usernames for employees of a
company from the employees' last names and employee IDs.

To concatenate the ``lastName`` and ``employeeID`` fields,
use the ``append()`` method. To make the username lowercase, use the
``toLower()`` method. To output the result as the ``username`` field,
use the ``project()`` method.

The following code shows the pipeline stage for this aggregation:

.. code-block:: java
   :copyable: true

   Arrays.asList(project(fields(
           computed("username",
                   current()
                           .getString("lastName")
                           .append(current()
                                   .getString("employeeID"))
                           .toLower()
   ))));

The following code provides an equivalent aggregation pipeline in
the Query API:

.. code-block:: javascript
   :copyable: true

   [
     {
       $project: {
         username: {
           $toLower: {
             $concat: ["$lastName", "$employeeID"],
           }
         }
       }
     }
   ]

More Information
----------------
